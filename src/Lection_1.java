import java.util.ArrayList;
import java.util.List;

public class Lection_1 {
    public static void main(String[] args) {

    }
    // оценка сложности алгоритма осуществляется чаще всего по отношению количества операций к объему входящих данных


// задача по вычислению допустимых делителей для числа n.
//Алгоритм вычисления весьма простой – нам нужно попробовать разделить n на
//каждое из чисел последовательности от 1 до n. Если остаток от деления числа n на
//некоторое число k равняется нулю, чисто k является делителем числа n.

//    public static List<Integer> availableDivider(int number){
//        List<Integer> result =  new ArrayList<>();
//        for (int i = 1; i < number ; i++) {
//            if (number% i ==0){
//                result.add(i);
//            }
//
//        } return result;
//    }
//}
    //Давайте напишем алгоритм поиска простых чисел
//    на промежутке от 1 до n


//    public static List<Integer> simpleNumbers(int max) {
//        List<Integer> result_simple = new ArrayList<>();
//        for (int i = 1; i <= max; i++) {
//            boolean simple = true;
//
//            for (int j = 2; j < i; j++) {
//                if (i % j == 0) {
//                    simple = false;
//
//                }
//
//            }
//            if (simple) {
//                result_simple.add(i);
//            }
//        }
//
//        return result_simple;
//    }

//    Давайте попробуем оценить сложность рекурсивного алгоритма вычисления чисел
//    Фибоначчи. Это числа, которые вычисляются путем сложения двух предыдущих
//    чисел последовательности, а первые 2 числа в ней 0 и 1.

    public static  int fib (int position){
        if (position == 1 || position ==2){
            return 1;
        }
        return fib(position-1) + fib(position -2);
    }


//    Чаще всего в работе с алгоритмами можно встретить следующие варианты
//    сложности:
//            ● O(1) – константная сложность. Не зависимо от размера входных данных,
//    количество шагов не изменяется. Например, поиск по хэш-таблице.
//● O(log n) – логарифмическая сложность. Рост размера входных данных почти не
//    оказывает влияния на рост сложности. Для увеличения сложности на 1, размер
//    входящих данных должен вырасти вдвое. Например, бинарный поиск.
//            ● O(n) – линейная сложность. Рост сложности линеен по отношению к росту размера
//    входных данных. Например, поиск допустимого делителя, поиск по
//    неотсортированному массиву.
//            ● O(n * log n) – рост сложности выше, чем у линейной, но ниже, чем у квадратичной
//    сложности алгоритма. Например, алгоритм быстрой сортировки, сортировки
//    пирамидой.
//● O(n
//2
//    ) – квадратичная сложность. Значительный рост сложности от размера
//    входящих данных. Например сортировка пузырьком
//● O(mn
//    ) – экспоненциальная сложность. При увеличении входящих данных на
//    единицу, сложность растет в m раз.

}

//    Получение элемента коллекции это O(1). Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O это будет O(1).
//        Перебор коллекции это O(n).
//        Вложенные циклы по той же коллекции это O(n2).
//        Разделяй и властвуй (Divide and Conquer) всегда O(log n).
//        Итерации которые используют “Разделяй и властвуй” (Divide and Conquer) это O(n log n).